{"version":3,"sources":["webpack://7dtd-map/./node_modules/idb/build/esm/wrap-idb-value.js","webpack://7dtd-map/./node_modules/idb/build/esm/index.js","webpack://7dtd-map/./src/lib/map-storage.ts","webpack://7dtd-map/./src/lib/map.ts","webpack://7dtd-map/./src/lib/throttled-invoker.ts","webpack://7dtd-map/./src/lib/utils.ts","webpack://7dtd-map/./src/map-renderer.ts","webpack://7dtd-map/webpack/bootstrap","webpack://7dtd-map/webpack/runtime/define property getters","webpack://7dtd-map/webpack/runtime/hasOwnProperty shorthand","webpack://7dtd-map/webpack/runtime/make namespace object","webpack://7dtd-map/webpack/startup"],"names":["idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","get","objectStoreNames","undefined","objectStore","wrap","set","value","has","transformCachableValue","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","this","storeNames","tx","call","sort","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","all","oldTraps","dbUpgrade","createObjectStore","keyPath","autoIncrement","LARGE_OBJECT_TYPES","CHANGE_LISTENERS","mapId","console","log","createMap","id","put","getDb","self","_db","isLargeObjectType","type","changeMap","currentId","map","getAll","newMap","data","Error","requireNonnull","DEFAULT_WORLD_NAME","mapIdOrUndefined","delete","t","fn","listener","push","markChar","putText","ctx","text","x","z","size","lineWidth","Math","round","strokeStyle","strokeText","fillText","canvas","fontFace","showBiomes","showSplat3","showSplat4","showRad","showPrefabs","biomesImg","splat3Img","splat4Img","radImg","brightness","scale","signSize","prefabs","FontFace","load","ff","fonts","add","markerCoords","throttledUpdater","updateImmediately","max","width","height","time","timeEnd","isBlank","context","getContext","filter","drawImage","imageSmoothingEnabled","font","family","fillStyle","textAlign","textBaseline","offsetX","offsetY","charOffsetX","charOffsetY","i","length","prefab","drawPrefabs","drawMark","asyncFunc","updateRequest","workerPromise","waitAnimationFrame","message","requireType","o","e","document","getElementById","lastChild","removeChild","d","toFixed","r","requestAnimationFrame","elevation","gx","gz","fileName","a","createElement","download","href","toDataURL","click","FIELDNAME_STORAGENAME_MAP","storage","MapStorage","onmessage","inMessage","Object","assign","update","entry","entries","postMessage","mapSize","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","definition","key","defineProperty","enumerable","obj","hasOwnProperty","Symbol","toStringTag"],"mappings":"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","file":"map-renderer.js","sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { DBSchema, IDBPDatabase, openDB } from \"idb\";\nimport { requireNonnull } from \"./utils\";\n\nconst DB_NAME = \"7dtd-map\";\nconst DB_VERSION = 2;\nconst DEFAULT_WORLD_NAME = \"New-World\";\n\ntype Db = IDBPDatabase<DbSchema>;\ninterface DbSchema extends DBSchema {\n  maps: {\n    value: MapObject;\n    key: number;\n  };\n  largeObjects: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value: LargeObject<any>;\n    key: [number, string];\n  };\n  selectedMap: {\n    value: { id: number; mapId: number };\n    key: number;\n  };\n}\n\nexport interface MapObject {\n  id: number;\n  name: string;\n}\n\nexport const LARGE_OBJECT_TYPES = [\n  \"biomes\",\n  \"splat3\",\n  \"splat4\",\n  \"rad\",\n  \"elevations\",\n  \"subElevations\",\n  \"prefabs\",\n  \"generationInfo\",\n] as const;\ntype LargeObjectType = typeof LARGE_OBJECT_TYPES[number];\nexport interface LargeObjects {\n  biomes: ImageBitmap;\n  splat3: ImageBitmap;\n  splat4: ImageBitmap;\n  rad: ImageBitmap;\n  elevations: Uint8Array;\n  subElevations: Uint8Array;\n  prefabs: Prefab[];\n  generationInfo: string;\n}\nexport interface LargeObject<T extends LargeObjectType> {\n  mapId: number;\n  type: T;\n  data: LargeObjects[T];\n}\n\nconst MAP_PROPERTY_TYPES = [\"maps\", ...LARGE_OBJECT_TYPES] as const;\ntype MapPropertyType = typeof MAP_PROPERTY_TYPES[number];\ntype MapPropertyValue<T extends MapPropertyType> = T extends LargeObjectType ? LargeObject<T> : DbSchema[\"maps\"][\"value\"];\ntype MapPropertyRawValue<T extends MapPropertyType> = T extends LargeObjectType\n  ? LargeObject<T>[\"data\"]\n  : DbSchema[\"maps\"][\"value\"][\"name\"];\n\nfunction dbUpgrade(db: Db, oldVersion: number, newVersion: number) {\n  for (let version = oldVersion + 1; version <= newVersion; version++) {\n    if (version === 1) {\n      db.createObjectStore(\"maps\", { keyPath: \"id\", autoIncrement: true });\n      db.createObjectStore(\"largeObjects\", { keyPath: [\"mapId\", \"type\"] });\n    }\n    if (version === 2) {\n      db.createObjectStore(\"selectedMap\", { keyPath: \"id\" });\n    }\n  }\n}\n\nconst CHANGE_LISTENERS: ((mapId: number, instance: MapStorage) => Promise<unknown> | unknown)[] = [\n  (mapId) => console.log(\"MapStorage change current map\", mapId),\n];\n\nexport class MapStorage {\n  _db?: Db;\n\n  async put<Type extends MapPropertyType>(type: Type, data: MapPropertyRawValue<Type>): Promise<void> {\n    const db = await getDb(this);\n    const mapId = await currentId(db);\n    if (isLargeObjectType(type)) {\n      await db.put(\"largeObjects\", { mapId, type, data });\n    } else if (type === \"maps\") {\n      await db.put(\"maps\", { id: mapId, name: data as MapPropertyRawValue<\"maps\"> });\n    } else {\n      throw Error(`Unreachable code: type=${type}`);\n    }\n  }\n\n  async getCurrent<Type extends MapPropertyType>(type: Type): Promise<MapPropertyValue<Type> | undefined> {\n    const db = await getDb(this);\n    const mapId = await currentId(db);\n    if (isLargeObjectType(type)) {\n      return (await db.get(\"largeObjects\", [mapId, type])) as MapPropertyValue<Type> | undefined;\n    } else if (type === \"maps\") {\n      return requireNonnull(await db.get(\"maps\", mapId), () => `Unexpected state: ${mapId}`) as MapPropertyValue<Type> | undefined;\n    } else {\n      throw Error(`Unreachable code: ${type}`);\n    }\n  }\n\n  async listMaps(): Promise<MapObject[]> {\n    const db = await getDb(this);\n    return db.getAll(\"maps\");\n  }\n\n  async createMap(name = DEFAULT_WORLD_NAME): Promise<MapObject> {\n    const db = await getDb(this);\n    return await createMap(db, name);\n  }\n\n  async deleteMap(mapIdOrUndefined?: number): Promise<void> {\n    const db = await getDb(this);\n    const mapId = mapIdOrUndefined ?? (await currentId(db));\n    await Promise.all([db.delete(\"maps\", mapId), ...LARGE_OBJECT_TYPES.map((t) => db.delete(\"largeObjects\", [mapId, t]))]);\n  }\n\n  async changeMap(mapId: number): Promise<void> {\n    const db = await getDb(this);\n    await Promise.all([changeMap(db, mapId), ...CHANGE_LISTENERS.map((fn) => fn(mapId, this))]);\n  }\n\n  async currentId(): Promise<number> {\n    return currentId(await getDb(this));\n  }\n\n  static addListener(listener: (mapId: number, self: MapStorage) => Promise<void>): void {\n    CHANGE_LISTENERS.push(listener);\n  }\n}\n\nasync function createMap(db: Db, name: string) {\n  const id = await db.put(\"maps\", { name } as MapObject);\n  return { id, name };\n}\n\nasync function getDb(self: MapStorage) {\n  if (!self._db) {\n    self._db = await openDB<DbSchema>(DB_NAME, DB_VERSION, { upgrade: dbUpgrade });\n  }\n  return self._db;\n}\n\nfunction isLargeObjectType(type: MapPropertyType): type is LargeObjectType {\n  return (LARGE_OBJECT_TYPES as readonly string[]).includes(type);\n}\n\nasync function changeMap(db: Db, mapId: number) {\n  await db.put(\"selectedMap\", { id: 0, mapId });\n}\n\nasync function currentId(db: Db): Promise<number> {\n  const map = await db.get(\"selectedMap\", 0);\n  if (map) {\n    return map.mapId;\n  }\n\n  const all = await db.getAll(\"maps\");\n  if (all[0]) {\n    await changeMap(db, all[0].id);\n    return currentId(db);\n  }\n\n  const newMap = await createMap(db, DEFAULT_WORLD_NAME);\n  await changeMap(db, newMap.id);\n  return currentId(db);\n}\n","import { FontFaceSet } from \"css-font-loading-module\";\nimport throttledInvoker from \"./throttled-invoker\";\n\nconst signChar = \"✘\";\nconst markChar = \"🚩️\";\n\ndeclare const fonts: FontFaceSet;\n\nexport default class GameMap {\n  biomesImg: ImageBitmap | null;\n  brightness: string;\n  canvas: OffscreenCanvas;\n  fontFace: FontFace | null = null;\n  throttledUpdater: () => Promise<void>;\n  markerCoords: Coords | null;\n  prefabs: HighlightedPrefab[];\n  radImg: ImageBitmap | null;\n  scale: number;\n  showBiomes: boolean;\n  showPrefabs: boolean;\n  showRad: boolean;\n  showSplat3: boolean;\n  showSplat4: boolean;\n  signSize: number;\n  splat3Img: ImageBitmap | null;\n  splat4Img: ImageBitmap | null;\n\n  constructor(canvas: OffscreenCanvas) {\n    this.canvas = canvas;\n    this.showBiomes = true;\n    this.showSplat3 = true;\n    this.showSplat4 = true;\n    this.showRad = true;\n    this.showPrefabs = true;\n    this.biomesImg = null;\n    this.splat3Img = null;\n    this.splat4Img = null;\n    this.radImg = null;\n    this.brightness = \"100%\";\n    this.scale = 0.1;\n    this.signSize = 200;\n    this.prefabs = [];\n\n    const fontFace = new FontFace(\"Noto Sans\", \"url(NotoEmoji-Regular.ttf)\");\n    fontFace.load().then((ff) => {\n      this.fontFace = ff;\n      fonts.add(ff);\n    });\n    this.markerCoords = null;\n\n    this.throttledUpdater = throttledInvoker(() => this.updateImmediately());\n  }\n\n  get width(): number {\n    return Math.max(this.biomesImg?.width ?? 0, this.splat3Img?.width ?? 0, this.splat4Img?.width ?? 0);\n  }\n\n  get height(): number {\n    return Math.max(this.biomesImg?.height ?? 0, this.splat3Img?.height ?? 0, this.splat4Img?.height ?? 0);\n  }\n\n  async update(): Promise<void> {\n    console.time(\"Map Update\");\n    await this.throttledUpdater();\n    console.timeEnd(\"Map Update\");\n  }\n\n  private isBlank(): boolean {\n    return !this.biomesImg && !this.splat3Img && !this.splat4Img;\n  }\n\n  async updateImmediately(): Promise<void> {\n    if (this.isBlank()) {\n      this.canvas.width = 1;\n      this.canvas.height = 1;\n      return;\n    }\n\n    this.canvas.width = this.width * this.scale;\n    this.canvas.height = this.height * this.scale;\n\n    const context = this.canvas.getContext(\"2d\");\n    if (!context) return;\n    context.scale(this.scale, this.scale);\n    context.filter = `brightness(${this.brightness})`;\n    if (this.biomesImg && this.showBiomes) {\n      context.drawImage(this.biomesImg, 0, 0, this.width, this.height);\n    }\n    if (this.splat3Img && this.showSplat3) {\n      context.drawImage(this.splat3Img, 0, 0, this.width, this.height);\n    }\n    if (this.splat4Img && this.showSplat4) {\n      context.drawImage(this.splat4Img, 0, 0, this.width, this.height);\n    }\n    context.filter = \"none\";\n    if (this.radImg && this.showRad) {\n      context.imageSmoothingEnabled = false;\n      context.drawImage(this.radImg, 0, 0, this.width, this.height);\n      context.imageSmoothingEnabled = true;\n    }\n    if (this.showPrefabs) {\n      drawPrefabs(this, context);\n    }\n    if (this.markerCoords) {\n      drawMark(this, context);\n    }\n  }\n}\n\nfunction drawPrefabs(map: GameMap, ctx: OffscreenCanvasRenderingContext2D) {\n  ctx.font = `${map.signSize}px ${map.fontFace?.family ?? \"\"}`;\n  ctx.fillStyle = \"red\";\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"middle\";\n\n  const offsetX = map.width / 2;\n  const offsetY = map.height / 2;\n\n  const charOffsetX = Math.round(map.signSize * 0.01);\n  const charOffsetY = Math.round(map.signSize * 0.05);\n\n  // Inverted iteration to overwrite signs by higher order prefabs\n  for (let i = map.prefabs.length - 1; i >= 0; i -= 1) {\n    const prefab = map.prefabs[i];\n    const x = offsetX + prefab.x + charOffsetX;\n    // prefab vertical positions are inverted for canvas coodinates\n    const z = offsetY - prefab.z + charOffsetY;\n    putText(ctx, { text: signChar, x, z, size: map.signSize });\n  }\n}\n\nfunction drawMark(map: GameMap, ctx: OffscreenCanvasRenderingContext2D) {\n  if (!map.markerCoords) return;\n\n  ctx.font = `${map.signSize}px ${map.fontFace?.family ?? \"\"}`;\n  ctx.fillStyle = \"red\";\n  ctx.textAlign = \"left\";\n  ctx.textBaseline = \"alphabetic\";\n\n  const offsetX = map.width / 2;\n  const offsetY = map.height / 2;\n  const charOffsetX = -1 * Math.round(map.signSize * 0.32);\n  const charOffsetY = -1 * Math.round(map.signSize * 0.1);\n\n  const x = offsetX + map.markerCoords.x + charOffsetX;\n  // prefab vertical positions are inverted for canvas coodinates\n  const z = offsetY - map.markerCoords.z + charOffsetY;\n\n  putText(ctx, { text: markChar, x, z, size: map.signSize });\n  ctx.strokeText(markChar, x, z);\n  ctx.fillText(markChar, x, z);\n}\n\ninterface MapSign {\n  text: string;\n  x: number;\n  z: number;\n  size: number;\n}\n\nfunction putText(ctx: OffscreenCanvasRenderingContext2D, { text, x, z, size }: MapSign) {\n  ctx.lineWidth = Math.round(size * 0.2);\n  ctx.strokeStyle = \"rgba(0, 0, 0, 0.8)\";\n  ctx.strokeText(text, x, z);\n\n  ctx.lineWidth = Math.round(size * 0.1);\n  ctx.strokeStyle = \"white\";\n  ctx.strokeText(text, x, z);\n\n  ctx.fillText(text, x, z);\n}\n","import { waitAnimationFrame } from \"./utils\";\n\nexport default function throttledInvoker(asyncFunc: () => Promise<void>): () => Promise<void> {\n  let updateRequest = false;\n  let workerPromise: Promise<void> | null = null;\n  return async () => {\n    updateRequest = true;\n\n    if (workerPromise) {\n      return;\n    }\n\n    workerPromise = (async () => {\n      while (updateRequest) {\n        updateRequest = false;\n        await asyncFunc();\n        await waitAnimationFrame();\n      }\n      workerPromise = null;\n    })();\n  };\n}\n","export function requireNonnull<T>(t: T | undefined | null, message = () => `Unexpected state: ${t}`): T {\n  if (t) return t;\n  else throw Error(message());\n}\n\nexport function requireType<T>(o: unknown, t: { new (...a: unknown[]): T }, message = () => `Unexpected type: ${o}`): T {\n  if (o instanceof t) return o;\n  throw Error(message());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | null | undefined, t?: { new (...a: unknown[]): T }): T {\n  const e = document.getElementById(requireNonnull(id));\n  return t ? requireType(requireNonnull(e), t) : (requireNonnull(e) as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport function formatCoords(\n  map: RectSize,\n  canvas: RectSize,\n  elevation: (coods: Coords, width: number) => number | null,\n  event: EventOffsets | null\n): string {\n  if (!event) return \"E/W: -, N/S: -, Elev: -\";\n\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * map.width) / canvas.width;\n  const gz = (event.offsetY * map.height) / canvas.height;\n  if (gx < 0 || gx >= map.width || gz < 0 || gz >= map.height) {\n    return \"E/W: -, N/S: -, Elev: -\";\n  }\n\n  // in-game coords (center offset)\n  const x = Math.round(gx - map.width / 2);\n  const z = Math.round(map.height / 2 - gz);\n  const e = elevation({ x: Math.round(gx), z: Math.round(gz) }, map.width) ?? \"-\";\n  return `E/W: ${x}, N/S: ${z}, Elev: ${e}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n","import GameMap from \"./lib/map\";\nimport { MapStorage } from \"./lib/map-storage\";\n\nexport type MapRendererInMessage = Partial<\n  Pick<\n    GameMap,\n    | \"canvas\"\n    | \"biomesImg\"\n    | \"splat3Img\"\n    | \"splat4Img\"\n    | \"radImg\"\n    | \"showBiomes\"\n    | \"showSplat3\"\n    | \"showSplat4\"\n    | \"showRad\"\n    | \"showPrefabs\"\n    | \"brightness\"\n    | \"scale\"\n    | \"signSize\"\n    | \"prefabs\"\n    | \"markerCoords\"\n  >\n>;\n\nexport interface MapRendererOutMessage {\n  mapSize: RectSize;\n}\n\ndeclare function postMessage(message: MapRendererOutMessage): void;\n\nconst FIELDNAME_STORAGENAME_MAP = {\n  biomesImg: \"biomes\",\n  splat3Img: \"splat3\",\n  splat4Img: \"splat4\",\n  radImg: \"rad\",\n} as const;\n\nlet map: GameMap | null = null;\nconst storage = new MapStorage();\n\nonmessage = async (event) => {\n  const inMessage = event.data as MapRendererInMessage;\n  if (!map) {\n    if (inMessage.canvas) {\n      map = new GameMap(inMessage.canvas);\n    } else {\n      throw Error(\"Unexpected state\");\n    }\n  }\n\n  await Object.assign(map, inMessage).update();\n  for (const entry of Object.entries(inMessage)) {\n    if (isStoreTarget(entry)) {\n      storage.put(FIELDNAME_STORAGENAME_MAP[entry[0]], entry[1]);\n    }\n  }\n  postMessage({\n    mapSize: {\n      width: map.width,\n      height: map.height,\n    },\n  });\n};\n\nfunction isStoreTarget(e: Entry<MapRendererInMessage>): e is [keyof typeof FIELDNAME_STORAGENAME_MAP, ImageBitmap] {\n  return e[0] in FIELDNAME_STORAGENAME_MAP;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(496);\n"],"sourceRoot":""}